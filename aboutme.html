<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        table, th, td {
                border: 1px solid black;
                border-collapse: collapse;
        }
    </style>
</head>
<body>
    <h1>Pavan kalyan</h1>
    <p>He is a man with golden heart. He always thinks about people and wish to do things which
        are usef/ull to humans especially old people. If the society is facing any problems then
        he make sure to help them by discussing this issue with government officials.
    </p>
    <img src="pavan.jpg" alt="The Man with Golden Heart">
    <hr>
    <h2>Favourite foods or drinks</h2>
    These are some of my favorite food items
    <table>
        <tr>
            <th>Item</th>
            <th>Place</th>
            <th>cost</th>
        </tr>
        <tr>
            <th>Biryani</th>
            <th>Namasthe India</th>
            <th>10USD</th>
        </tr>
        <tr>
            <th>pizza</th>
            <th>Dominos</th>
            <th>5USD</th>
        </tr>
        <tr>
            <th>Burger</th>
            <th>Burger King</th>
            <th>6USD</th>
        </tr>
        <tr>
            <th>Milkshake</th>
            <th>StarBucks</th>
            <th>7USD</th>
        </tr>
    </table>
    <hr>
    <h2>Bipartite Graph</h2>
    <blockquote cite = "https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/">Breadth first search is a graph traversal algorithm that starts traversing the graph from root node and explores all the neighbouring nodes. Then, it selects the nearest node and explore all the unexplored nodes. The algorithm follows the same process for each of the nearest node until it finds the goal.</blockquote>
    <a href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/">for more</a>
    <pre>
        vector<vector<int>> adj;  // adjacency list representation
            int n; // number of nodes
            int s; // source vertex
            
            queue<int> q;
            vector<bool> used(n);
            vector<int> d(n), p(n);
            
            q.push(s);
            used[s] = true;
            p[s] = -1;
            while (!q.empty()) {
                int v = q.front();
                q.pop();
                for (int u : adj[v]) {
                    if (!used[u]) {
                        used[u] = true;
                        q.push(u);
                        d[u] = d[v] + 1;
                        p[u] = v;
                    }
                }
            }
    </pre>
</body>
</html>